---
title: "Endoderm_TC_core_runs"
author: "Lauren Blake"
date: "October 27, 2016"
output: html_document
---

## Introduction

The goal of this script is to process the data from the 2 core runs of our endoderm time course project. The data was sequenced on an Illumina 4000 at the University of Chicago Genomics Core Facility. 
There are 2 species (humans and chimps) with 6 human iPSC lines with 2 replicates and 4 chimp iPSC lines with 4 replicates. RNA was extracted from the iPSCs for each day of the differentation into endoderm for a total of 4 days. 

## PLOTS OF UNMAPPED AND MAPPED READS

```{r load}
# Load necessary libraries
library(ggplot2)
## Warning: package 'ggplot2' was built under R version 3.2.3
library(scales)
source("~/Desktop/Endoderm_TC/ashlar-trial/analysis/chunk-options.R")

# Get data for unmapped and mapped reads
Endoderm_mapping_2_core_runs <- read.csv("~/Desktop/Endoderm_TC/Endoderm_mapping_2_core_runs.csv")



# Plot mapped reads per sample with a line at 10 million reads

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Total_mapped, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (2 core runs)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot mapped reads per sample AFTER subsampling D0_3649_0116

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Total_mapped_post_subsample, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (2 core runs, post-subsampling)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)


# Plot mapped reads per sample for core run 1

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_mapped_run1, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (core run 1)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot mapped reads per sample for core run 1 AFTER subsampling D0_3649_0116

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_mapped_post_subsample_run1, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (core run 1, post-subsampling)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot mapped reads per sample for core run 2

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_mapped_run2, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (core run 2)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot mapped reads per sample for core run 2

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_mapped_post_subsample_run2, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (core run 2, post-subsampling)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

```



```{r both cores}
# Plot for unmapped reads/sample for both core runs

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Total_unmapped, fill = Species)) + ylab("Number of unmapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Unmapped reads for all samples (2 core runs)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot for unmapped reads/sample

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_unmapped_run1, fill = Species)) + ylab("Number of unmapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Unmapped reads for all samples  (core run 1)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot for unmapped reads/lane in core run 1

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Lane_run1), y = Reads_unmapped_run1, fill = Species)) + ylab("Number of unmapped reads") + xlab("Lane number") + geom_bar(stat = "identity", colour = "black")  + ggtitle("Unmapped reads for all samples  (core run 1)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot for unmapped reads/sample

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_unmapped_run2, fill = Species)) + ylab("Number of unmapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Unmapped reads for all samples  (core run 2)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot for unmapped reads/lane in core run 1

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Lane_run2), y = Reads_unmapped_run2, fill = Species)) + ylab("Number of unmapped reads") + xlab("Lane number") + geom_bar(stat = "identity", colour = "black") + ggtitle("Unmapped reads for all samples  (core run 2)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)


```

Originally, we had considered subsampling to the median. 
```{r re subsampling}
# Originally, we had considered subsampling to the median. Find the median of the mapped reads (not including sample D0_3647_0116)

median_test <- as.data.frame(Endoderm_mapping_2_core_runs$Total_mapped)
median_run <- as.data.frame(median_test[-10,])

median(as.numeric(t(median_run)))

#We will subsample Sample D036470116 to the median number of reads, 35953173 reads.
#Actual number of reads in  SampleD036470116 post subsampling: 35644778 reads.
```

Given the distribution of the mapped reads, we will subsample to the second highest value.

```{r subsample to second highest value}

# Plot mapped reads per sample with a line at 10 million reads

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Total_mapped, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (2 core runs)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot mapped reads per sample AFTER subsampling D0_3649_0116

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Total_mapped_post_subsample, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (2 core runs, post-subsampling)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)


# Plot mapped reads per sample for core run 1

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_mapped_run1, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (core run 1)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot mapped reads per sample for core run 1 AFTER subsampling D0_3649_0116

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_mapped_post_subsample_run1, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (core run 1, post-subsampling)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot mapped reads per sample for core run 2

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_mapped_run2, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (core run 2)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)

# Plot mapped reads per sample for core run 2

ggplot(Endoderm_mapping_2_core_runs, aes(x = factor(Sample), y = Reads_mapped_post_subsample_run2, fill = Species)) + ylab("Number of mapped reads") + xlab("Sample name") + geom_bar(stat = "identity", colour = "black") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("Sample name") + ggtitle("Mapped reads for all samples  (core run 2, post-subsampling)") + geom_hline(yintercept = 10000000) + scale_y_continuous(labels = comma)


```

## VISUALIZATION OF THE RAW DATA 

```{r raw data}
# Load libraries

library("gplots")
library("RColorBrewer")
library("scales")
library("edgeR")

# Load colors 

colors <- colorRampPalette(c(brewer.pal(9, "Blues")[1],brewer.pal(9, "Blues")[9]))(100)
pal <- c(brewer.pal(9, "Set1"), brewer.pal(8, "Set2"), brewer.pal(12, "Set3"))

# Set expression cutoff

expr_cutoff <- 1.5

# Load count data

gene_counts_combined_raw_data <- read.delim("~/Desktop/Endoderm_TC/gene_counts_combined.txt")
#gene_counts_combined_raw_data <- read.delim("~/Dropbox/Endoderm TC/gene_counts_combined_raw_data.txt", header=FALSE, stringsAsFactors=FALSE)
counts_genes <- gene_counts_combined_raw_data[1:30030,2:65]
rownames(counts_genes) <- gene_counts_combined_raw_data[1:30030,1]
#counts_genes <- gene_counts

# Load sample info

Endoderm_mapping_core_1 <- read.csv("~/Desktop/Endoderm_TC/Endoderm_mapping_core_1.csv")

# Make labels with species and day
species <- Endoderm_mapping_core_1$Species
Species <- Endoderm_mapping_core_1$Species
day <- Endoderm_mapping_core_1$Day
individual <- Endoderm_mapping_core_1$Individual
Sample_ID <- Endoderm_mapping_core_1$Sample_ID

labels <- paste(species, day, sep=" ")

```

```{r}
# Hierarchical clustering on raw data

cors <- cor(counts_genes, method="spearman", use="pairwise.complete.obs")

heatmap.2( cors, scale="column", col = colors, margins = c(12, 12), trace='none', denscol="white", labCol=labels, ColSideColors=pal[as.integer(as.factor(Endoderm_mapping_core_1$Species))], RowSideColors=pal[as.integer(as.factor(Endoderm_mapping_core_1$Day))+9], cexCol = 0.2 + 1/log10(15), cexRow = 0.2 + 1/log10(15))

 
```

```{r functions}
#PCA function (original code from Julien Roux)
#Load in the plot_scores function
plot_scores <- function(pca, scores, n, m, cols, points=F, pchs =20, legend=F){
  xmin <- min(scores[,n]) - (max(scores[,n]) - min(scores[,n]))*0.05
  if (legend == T){ ## let some room (35%) for a legend                                                                                                                                                 
    xmax <- max(scores[,n]) + (max(scores[,n]) - min(scores[,n]))*0.50
  }
  else {
    xmax <- max(scores[,n]) + (max(scores[,n]) - min(scores[,n]))*0.05
  }
  ymin <- min(scores[,m]) - (max(scores[,m]) - min(scores[,m]))*0.05
  ymax <- max(scores[,m]) + (max(scores[,m]) - min(scores[,m]))*0.05
  plot(scores[,n], scores[,m], xlab=paste("PC", n, ": ", round(summary(pca)$importance[2,n],3)*100, "% variance explained", sep=""), ylab=paste("PC", m, ": ", round(summary(pca)$importance[2,m],3)*100, "% variance explained", sep=""), xlim=c(xmin, xmax), ylim=c(ymin, ymax), type="n")
  if (points == F){
    text(scores[,n],scores[,m], rownames(scores), col=cols, cex=1)
  }
  else {
    points(scores[,n],scores[,m], col=cols, pch=pchs, cex=1.3)
  }
}

# Run the PCA 

# Check that there's no "NAs" in the data
select <- counts_genes
summary(apply(select, 1, var) == 0)

row_sub = apply(counts_genes, 1, function(row) all(row !=0 ))
counts_genes_no0 <- counts_genes[row_sub,]

# Perform PCA

pca_genes <- prcomp(t(counts_genes_no0), scale = T)
scores <- pca_genes$x

#Make PCA plots with the factors colored by day

### PCs 1 and 2 Raw Data
for (n in 1:1){
  col.v <- pal[as.integer(species)]
  plot_scores(pca_genes, scores, n, n+1, col.v)
}

for (n in 1:1){
  col.v <- pal[as.integer(species)]
  plot_scores(pca_genes, scores, n, n+1, col.v)
}
```

## INITIALIZE NORMALIZATION

```{r normalization 1}
# Let's see what happens when we take the log2 of the raw counts

log_counts_genes <- as.data.frame(log2(counts_genes))
head(log_counts_genes)

# Plot density (a) by species and (b) by day
plotDensities(log_counts_genes, col=pal[as.numeric(Endoderm_mapping_core_1$Species)], legend="topright")

plotDensities(log_counts_genes, col=pal[as.numeric(Endoderm_mapping_core_1$Day)], legend="topright")

# Log2(CPM)

cpm <- cpm(counts_genes, log=TRUE)

# Make plot 
hist(cpm, main = "log2(CPM) values in unfiltered data (n = 64 samples)", breaks = 100, ylim = c(0, 50000), xlab = "log2(CPM) values")
abline(v = expr_cutoff, col = "red", lwd = 3)

# Plot density (a) by species and (b) by day
plotDensities(cpm, col=pal[as.numeric(Endoderm_mapping_core_1$Species)], legend="topright")

plotDensities(cpm, col=pal[as.numeric(Endoderm_mapping_core_1$Day)], legend="topright")

# Plot library size

#boxplot_library_size <- ggplot(dge_original$samples, aes(x = as.factor(Endoderm_mapping_core_1$Day), y = dge_original$samples$lib.size, fill = Endoderm_mapping_core_1$Species)) + geom_boxplot()

#boxplot_library_size + labs(title = "Library size by day") + labs(y = "Library size") + labs(x = "Day") + guides(fill=guide_legend(title="Species"))

```

### Filtering lowly expressed genes

We are beginning with 30030 genes and 64 samples (8 samples/species x 4 timepoints/species x 2 species)
Based on what we have learned from Roux and Blake (http://lauren-blake.github.io/Reg_Evo_Primates/analysis/Correlation_bet_tech_factors_in_best_set_and_expression_stringent_filtering.html), we will use a cutoff of log2(CPM) > 1.5 in at least 16 of the human samples and 16 of the chimp samples.

```{r filter lowly expressed genes}
expr_cutoff <- 1.5

# Make plot 
hist(cpm, main = "log2(CPM) values in unfiltered data (n = 64 samples)", breaks = 100, ylim = c(0, 50000), xlab = "log2(CPM) values")
abline(v = expr_cutoff, col = "red", lwd = 3)

# Filter data

humans <- c(1:8, 17:24, 33:40, 49:56)
chimps <- c(9:16, 25:32, 41:48, 57:64 )


cpm_filtered <- (rowSums(cpm[,humans] > 1.5) > 16 & rowSums(cpm[,chimps] > 1.5) > 16)

genes_in_cutoff <- cpm[cpm_filtered==TRUE,]
dim(genes_in_cutoff)

# Make a histogram of the filtered data 

hist(as.numeric(unlist(genes_in_cutoff)), main = "log2(CPM) values in filtered data (n = 64 samples, 10,270 genes)", breaks = 100, ylim = c(0, 50000), xlab = "log2(CPM) values")

```

## About GC Content Normalization

Roux and Blake's comparative analysis (http://lauren-blake.github.io/Reg_Evo_Primates/analysis/GC_content_normalization_CHT.html) showed that GC content normalization does not substantially impact gene counts. Therefore, we will not perform it in this analysis. 

## Correction for library size

```{r correct for library size}
# Find the original counts of all of the genes that fit the criteria 

counts_genes_in_cutoff <- counts_genes[cpm_filtered==TRUE,]
dim(counts_genes_in_cutoff)

# Take the TMM of the counts only for the genes that remain after filtering

dge_in_cutoff <- DGEList(counts=as.matrix(counts_genes_in_cutoff), genes=rownames(counts_genes_in_cutoff), group = as.character(t(labels)))
dge_in_cutoff <- calcNormFactors(dge_in_cutoff)

cpm_in_cutoff <- cpm(dge_in_cutoff, normalized.lib.sizes=TRUE, log=TRUE)

head(summary(cpm_in_cutoff))

# Make density plots of the filtered data

plotDensities(cpm_in_cutoff, col=pal[as.numeric(species)], legend="topright")

plotDensities(cpm_in_cutoff, col=pal[as.numeric(day)], legend="topright")

#gplots::heatmap.2(x=as.matrix(t(cpm_in_cutoff)),
#                  , distfun = dist(x, method = "euclidean"), 
#                  hclustfun = function(x) hclust(dist(x), method = "average"), tracecol=NA, col=colors, denscol="white", ColSideColors=pal[as.integer(as.factor(Day))+9])

cors <- cor(cpm_in_cutoff, method="spearman", use="pairwise.complete.obs")

heatmap.2( cors, scale="column", col = colors, margins = c(12, 12), trace='none', denscol="white", labCol=labels, ColSideColors=pal[as.integer(as.factor(Endoderm_mapping_core_1$Species))], RowSideColors=pal[as.integer(as.factor(Endoderm_mapping_core_1$Day))+9], cexCol = 0.2 + 1/log10(15), cexRow = 0.2 + 1/log10(15))


```

## Visualizing the filtered data

```{r}
# Make PCA plots with the factors colored by day

pca_genes <- prcomp(t(cpm_in_cutoff), scale = T)
scores <- pca_genes$x

### PCs 1 and 2 
for (n in 1:1){
  col.v <- pal[as.integer(species)]
  plot_scores(pca_genes, scores, n, n+1, col.v)
}

for (n in 2:2){
  col.v <- pal[as.integer(species)]
  plot_scores(pca_genes, scores, n, n+1, col.v)
}

```

## PCA with 64 samples (supplement)

### Without cyclic loess normalization (supplement)

```{r PCA 63}
# Make PCA plots with the factors colored by day

pca_genes <- prcomp(t(cpm_in_cutoff), scale = T, retx = TRUE, center = TRUE)

matrixpca <- pca_genes$x
pc1 <- matrixpca[,1]
pc2 <- matrixpca[,2]
pc3 <- matrixpca[,3]
pc4 <- matrixpca[,4]
pc5 <- matrixpca[,5]

pcs <- data.frame(pc1, pc2, pc3, pc4, pc5)

summary <- summary(pca_genes)

#dev.off()

ggplot(data=pcs, aes(x=pc1, y=pc2, color=day, shape=Species, size=2)) + geom_point(aes(colour = as.factor(day))) +  scale_colour_manual(name="Day",  
                      values = c("0"=rgb(239/255, 110/255, 99/255, 1), "1"= rgb(0/255, 180/255, 81/255, 1), "2"=rgb(0/255, 177/255, 219/255, 1),
                                 "3"=rgb(199/255, 124/255, 255/255,1))) + xlab(paste("PC1 (",(summary$importance[2,1]*100), "% of variance)")) + ylab(paste("PC2 (",(summary$importance[2,2]*100), "% of variance)")) + scale_size(guide = 'none')  + theme_bw()  + ggtitle("PCs 1 and 2 from TMM normalized expression (64 samples)")

```

### With cyclic loess normalization (supplement)

```{r cyclic loess norm}
# Cyclic loess normalization

# Make the design matrix (so that you can use voom to perform the cyclic loess normalization )
condition <- factor(paste(species,day,sep="."))
design <- model.matrix(~ 0 + condition)
colnames(design) <- gsub("condition", "", dput(colnames(design)))

# We want a random effect term for individual. As a result, we want to run voom twice. See https://support.bioconductor.org/p/59700/

cpm.voom <- voom(dge_in_cutoff, design, normalize.method="cyclicloess")


# Make PCA plots with the factors colored by day

pca_genes <- prcomp(t(cpm.voom$E), scale = T, retx = TRUE, center = TRUE)

matrixpca <- pca_genes$x
pc1 <- matrixpca[,1]
pc2 <- matrixpca[,2]
pc3 <- matrixpca[,3]
pc4 <- matrixpca[,4]
pc5 <- matrixpca[,5]

pcs <- data.frame(pc1, pc2, pc3, pc4, pc5)

summary <- summary(pca_genes)

#dev.off()

ggplot(data=pcs, aes(x=pc1, y=pc2, color=day, shape=Species, size=2)) + geom_point(aes(colour = as.factor(day))) +  scale_colour_manual(name="Day",  
                      values = c("0"=rgb(239/255, 110/255, 99/255, 1), "1"= rgb(0/255, 180/255, 81/255, 1), "2"=rgb(0/255, 177/255, 219/255, 1),
                                 "3"=rgb(199/255, 124/255, 255/255,1))) + xlab(paste("PC1 (",(summary$importance[2,1]*100),"% of variance)")) + ylab(paste("PC2 (",(summary$importance[2,2]*100),"% of variance)")) + scale_size(guide = 'none')  + theme_bw()  + ggtitle("PCs 1 and 2 from TMM+cyclic loess normalized expression (64 samples)")



```



From the PCA plot, we see that Sample D0201570116 is a clear outlier and doesn't cluster with anything, including its technical replicate. We will remove this sample and then go through the same process as above to visualize the data. 

## Normalization after removal of Sample D0201570116

```{r 63 samples}
# Get data and sample info

counts_genes63 <- counts_genes[,-2]
dim(counts_genes63)

After_removal_sample_info <- read.csv("~/Desktop/Endoderm_TC/After_removal_sample_info.csv")

Species <- After_removal_sample_info$Species
species <- After_removal_sample_info$Species
day <- After_removal_sample_info$Day
individual <- After_removal_sample_info$Individual
Sample_ID <- After_removal_sample_info$Sample_ID
labels <- paste(Sample_ID, day, sep=" ")

# Log2(CPM)

cpm <- cpm(counts_genes63, log=TRUE)

# Make plot 
hist(cpm, main = "log2(CPM) values in unfiltered data (n = 64 samples)", breaks = 100, ylim = c(0, 50000), xlab = "log2(CPM) values")
abline(v = 1.5, col = "red", lwd = 3)

# Filter lowly expressed genes

humans <- c(1:7, 16:23, 32:39, 48:55)
chimps <- c(8:15, 24:31, 40:47, 56:63)

cpm_filtered <- (rowSums(cpm[,humans] > 1.5) > 15 & rowSums(cpm[,chimps] > 1.5) > 16)

genes_in_cutoff <- cpm[cpm_filtered==TRUE,]
dim(genes_in_cutoff)

# Find the original counts of all of the genes that fit the criteria 

counts_genes_in_cutoff <- counts_genes63[cpm_filtered==TRUE,]
dim(counts_genes_in_cutoff)

# Take the TMM of the counts only for the genes that remain after filtering

dge_in_cutoff <- DGEList(counts=as.matrix(counts_genes_in_cutoff), genes=rownames(counts_genes_in_cutoff), group = as.character(t(labels)))
dge_in_cutoff <- calcNormFactors(dge_in_cutoff)

cpm_in_cutoff <- cpm(dge_in_cutoff, normalized.lib.sizes=TRUE, log=TRUE)

head(summary(cpm_in_cutoff))

# Make plot 
hist(cpm_in_cutoff, main = "log2(CPM) values in filtered data (10,304 genes from 63 samples)", breaks = 100, ylim = c(0, 50000), xlab = "log2(CPM) values")

# Make table of the normalized data

# write.table(cpm_in_cutoff,file="~/Dropbox/Endoderm TC/gene_counts_combined_norm_data.txt",sep="\t", col.names = T, row.names = T)


```

There are 10,304 genes remaining. 


```{r PCA}
library("ggplot2")
dev.off()

# Make PCA plots with the factors colored by day

pca_genes <- prcomp(t(cpm_in_cutoff), scale = T, retx = TRUE, center = TRUE)
scores <- pca_genes$x

### PCs Plots on filtered and normalized data
# PCs 1 and 2
for (n in 1:1){
  col.v <- pal[as.integer(species)]
  plot_scores(pca_genes, scores, n, n+1, col.v)
}
for (n in 1:1){
  col.v <- pal[as.integer(day)]
  plot_scores(pca_genes, scores, n, n+1, col.v)
}

matrixpca <- pca_genes$x
pc1 <- matrixpca[,1]
pc2 <- matrixpca[,2]
pc3 <- matrixpca[,3]
pc4 <- matrixpca[,4]
pc5 <- matrixpca[,5]
pc6 <- matrixpca[,6]
pc7 <- matrixpca[,7]
pc8 <- matrixpca[,8]
pc9 <- matrixpca[,9]
pc10 <- matrixpca[,10]

pcs <- data.frame(pc1, pc2, pc3, pc4, pc5, pc6, pc7, pc8, pc9, pc10)

summary <- summary(pca_genes)

ggplot(data=pcs, aes(x=pc1, y=pc2, color=day, shape=Species, size=2)) + geom_point(aes(colour = as.factor(day))) +  scale_colour_manual(name="Day",  
                      values = c("0"=rgb(239/255, 110/255, 99/255, 1), "1"= rgb(0/255, 180/255, 81/255, 1), "2"=rgb(0/255, 177/255, 219/255, 1),
                                 "3"=rgb(199/255, 124/255, 255/255,1))) + xlab(paste("PC1 (",(summary$importance[2,1]*100),"% of variance)")) + ylab(paste("PC2 (",(summary$importance[2,2]*100),"% of variance)")) + scale_size(guide = 'none')  + theme_bw()  + ggtitle("PCs 1 and 2 from TMM normalized log2 CPM (63 samples)")






```

### PCA of TMM+cyclic loess normalized data (main paper and supplement)

```{r PCA TMM+cyclic}
cpm_cyclicloess <- read.delim("~/Desktop/Endoderm_TC/ashlar-trial/data/cpm_cyclicloess.txt")

pca_genes <- prcomp(t(cpm_cyclicloess), scale = T, retx = TRUE, center = TRUE)

matrixpca <- pca_genes$x
pc1 <- matrixpca[,1]
pc2 <- matrixpca[,2]
pc3 <- matrixpca[,3]
pc4 <- matrixpca[,4]
pc5 <- matrixpca[,5]

pcs <- data.frame(pc1, pc2, pc3, pc4, pc5, pc6, pc7, pc8, pc9, pc10)

summary <- summary(pca_genes)

#dev.off()

ggplot(data=pcs, aes(x=pc1, y=pc2, color=day, shape=Species, size=2)) + geom_point(aes(colour = as.factor(day))) +  scale_colour_manual(name="Day",  
                      values = c("0"=rgb(239/255, 110/255, 99/255, 1), "1"= rgb(0/255, 180/255, 81/255, 1), "2"=rgb(0/255, 177/255, 219/255, 1),
                                 "3"=rgb(199/255, 124/255, 255/255,1))) + xlab(paste("PC1 (",(summary$importance[2,1]*100),"% of variance)")) + ylab(paste("PC2 (",(summary$importance[2,2]*100),"% of variance)")) + scale_size(guide = 'none')  + theme_bw()  + ggtitle("PCs 1 and 2 from TMM+loess normalized expression (63 samples)")
     

```

### Heatmaps of normalized data

```{r}

After_removal_sample_info <- read.csv("~/Desktop/Endoderm_TC/ashlar-trial/data/After_removal_sample_info.csv")

day <- After_removal_sample_info$Day
day <- as.factor(day)
Sample_ID <- After_removal_sample_info$Sample_ID
labels <- paste(Sample_ID, day, sep=" ")

# Using Spearman's correlation

cors_sp <- cor(cpm_cyclicloess, method="spearman", use="pairwise.complete.obs")

pal <- c(rgb(239/255, 110/255, 99/255, 1), rgb(0/255, 180/255, 81/255, 1), rgb(0/255, 177/255, 219/255, 1), rgb(199/255, 124/255, 255/255,1))

make_heatmap <- heatmap.2( cors_sp, scale="none", col = colors, margins = c(12, 12), trace='none', denscol="white", labCol= labels, labRow= labels, ColSideColors=pal[as.integer(as.factor(day))], RowSideColors=pal[as.integer(as.factor(day))], cexCol = 0.2 + 1/log10(15), cexRow = 0.2 + 1/log10(15))

# Using Pearson's correlation

cors_pe <- cor(cpm_cyclicloess, method="pearson", use="pairwise.complete.obs")

pal <- c(rgb(239/255, 110/255, 99/255, 1), rgb(0/255, 180/255, 81/255, 1), rgb(0/255, 177/255, 219/255, 1), rgb(199/255, 124/255, 255/255,1))

make_heatmap <- heatmap.2( cors_pe, scale="none", col = colors, margins = c(12, 12), trace='none', denscol="white", labCol= labels, labRow= labels, ColSideColors=pal[as.integer(as.factor(day))], RowSideColors=pal[as.integer(as.factor(day))], cexCol = 0.2 + 1/log10(15), cexRow = 0.2 + 1/log10(15))


   
```


PC 1 is correlated with day, PC 2 with species, PC 3 is somewhat by species, PC 4 with day, and PC 5 separates one sample (D228815) from the rest of the samples. 

## Is differentiation batch or individual a stronger driver of variation of gene expression in our samples?

```{r}
# Load data about differentiation batch

After_removal_sample_info <- read.csv("~/Desktop/Endoderm_TC/After_removal_sample_info.csv")

differentiation_batch <- After_removal_sample_info$Reprogramming_batch

# Find the numbers in each batch (should be 32 in batch 1 and 31 in batch 2)
def_batch1 <- which(differentiation_batch == 1)
length(def_batch1)

def_batch2 <- which(differentiation_batch == 2)
length(def_batch2)

# Load data about Individual

individual <- After_removal_sample_info$Individual

#dev.off()
```

We want to make sure that differentiation batch nor individual is perfectly correlated with PCs 1-2 (which are correlated with our biological variables of interest).

### Differentiation batch
```{r}

Species <- After_removal_sample_info$Species
species <- After_removal_sample_info$Species
day <- After_removal_sample_info$Day
individual <- After_removal_sample_info$Individual
Sample_ID <- After_removal_sample_info$Sample_ID
labels <- paste(Sample_ID, day, sep=" ")


# Check dimension of pcs

dim(pcs)

# Differentiation batch

pvaluesandr2_differentiation_batch = matrix(data = NA, nrow = 10, ncol = 2, dimnames = list(c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10"), c("Diff_batch p_val", "Diff_batch R^2")))

j = 1
  for (j in 1:10){
  
  checkPC1 <- lm(pcs[,j] ~ as.factor(differentiation_batch))

#Get the summary statistics from it
  summary(checkPC1)

#Get the p-value of the F-statistic
  summary(checkPC1)$fstatistic

  fstat <- as.data.frame(summary(checkPC1)$fstatistic)
  p_fstat <- 1-pf(fstat[1,], fstat[2,], fstat[3,])
  
#Fraction of the variance explained by the model
  r2_value <- summary(checkPC1)$r.squared

#Put the summary statistics into the matrix w

  pvaluesandr2_differentiation_batch[j, 1] <- p_fstat
  pvaluesandr2_differentiation_batch[j, 2] <- r2_value
  
}

pvaluesandr2_differentiation_batch

# PCs 1 and 2 by differentiation batch

ggplot(data=pcs, aes(x=pc1, y=pc2, color=as.factor(day), shape=as.factor(differentiation_batch), size=2)) + geom_point() + theme_bw() + xlab(paste("PC1 (",(summary$importance[2,1]*100), "% of variance)")) + ylab(paste("PC2 (",(summary$importance[2,2]*100), "% of variance)")) + ggtitle("PCs 1 and 2 of Normalized Data") + guides(color = guide_legend(order=1), size = FALSE, shape = guide_legend(order=2)) + scale_color_discrete(name  ="Day", labels=c("0", "1", "2", "3")) + scale_shape_discrete(name  ="Differentiation Batch", labels=c("2015", "2016")) 



# PCs 3 and 4 by differentiation batch

ggplot(data=pcs, aes(x=pc3, y=pc4, color=as.factor(day+1), shape=as.factor(differentiation_batch), size=2)) + geom_point() + theme_bw()  + xlab(paste("PC3 (",(summary$importance[2,3]*100), "% of variance)")) + ylab(paste("PC4 (",(summary$importance[2,4]*100), "% of variance)")) + ggtitle("PCs 3 and 4 of Normalized Data") + guides(color = guide_legend(order=1), size = FALSE, shape = guide_legend(order=2)) + scale_color_discrete(name  ="Day", labels=c("0", "1", "2", "3")) + scale_shape_discrete(name  ="Differentiation Batch", labels=c("2015", "2016")) 

# PCs 4 and 5 by differentiation batch

ggplot(data=pcs, aes(x=pc4, y=pc5, color=as.factor(day+1), shape=as.factor(differentiation_batch), size=2)) + geom_point() + theme_bw() + xlab(paste("PC4 (",(summary$importance[2,4]*100), "% of variance)")) + ylab(paste("PC5 (",(summary$importance[2,5]*100), "% of variance)")) + ggtitle("PCs 4 and 5 of Normalized Data") + guides(color = guide_legend(order=1), size = FALSE, shape = guide_legend(order=2)) + scale_color_discrete(name  ="Day", labels=c("0", "1", "2", "3")) + scale_shape_discrete(name  ="Differentiation Batch", labels=c("2015", "2016")) 
#ggplotly()
```

Differentiation batch is most highly correlated with PC5 (p-value = 0.00994664), then PC3, then PC8. Note that in PC5, the sample 28815 is an outlier. Therefore, we will perform this analysis below without the sample. 

### Individual

```{r}
# Individual

pvaluesandr2_individual = matrix(data = NA, nrow = 10, ncol = 2, dimnames = list(c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10"), c("Individual p_val", "Individual R^2")))

j = 1
  for (j in 1:10){
  
  checkPC1 <- lm(pcs[,j] ~ as.factor(individual))

#Get the summary statistics from it
  summary(checkPC1)

#Get the p-value of the F-statistic
  summary(checkPC1)$fstatistic

  fstat <- as.data.frame(summary(checkPC1)$fstatistic)
  p_fstat <- 1-pf(fstat[1,], fstat[2,], fstat[3,])
  
#Fraction of the variance explained by the model
  r2_value <- summary(checkPC1)$r.squared

#Put the summary statistics into the matrix w

  pvaluesandr2_individual[j, 1] <- p_fstat
  pvaluesandr2_individual[j, 2] <- r2_value
  
}

pvaluesandr2_individual

# PCs 1 and 2 by individual

ggplot(data=pcs, aes(x=pc1, y=pc2, color=as.factor(day+1), shape=as.factor(individual), size=2)) + geom_point() + theme_bw()  + xlab(paste("PC1 (",(summary$importance[2,1]*100), "% of variance)")) + ylab(paste("PC2 (",(summary$importance[2,2]*100), "% of variance)")) + ggtitle("PCs 1 and 2 of Normalized Data") + theme_bw() + guides(color = guide_legend(order=1), size = FALSE, shape = guide_legend(order=2)) + scale_shape_manual(values = c( 0,1,2,3,4,6,7,8,9,10)) + scale_color_discrete(name  ="Day", labels=c("0", "1", "2", "3"))

# PCs 3 and 4 by individual

ggplot(data=pcs, aes(x=pc3, y=pc4, color=as.factor(day+1), shape=as.factor(individual), size=2))  + geom_point() + theme_bw()  + xlab(paste("PC3 (",(summary$importance[2,3]*100), "% of variance)")) + ylab(paste("PC4 (",(summary$importance[2,4]*100), "% of variance)")) + ggtitle("PCs 1 and 2 of Normalized Data") + guides(color = guide_legend(order=1), size = FALSE, shape = guide_legend(order=2)) + theme_bw() + scale_shape_manual(values = c( 0,1,2,3,4,6,7,8,9,10)) + scale_color_discrete(name  ="Day", labels=c("0", "1", "2", "3"))

# PCs 3 and 4 by individual

pcs <- data.frame(pc1, pc2, pc3, pc4, pc5, pc6, pc7, pc8, pc9, pc10)

summary <- summary(pca_genes)


humans <- c(1:7, 16:23, 32:39, 48:55)
chimps <- c(8:15, 24:31, 40:47, 56:63)

ggplot(data=pcs[humans,], aes(x=pc1, y=pc3, color=as.factor(day[humans]+1), shape=as.factor(individual[humans]), size=2)) + geom_point() + xlab("PC1") + ylab("PC3") + ggtitle("PCs 1 and 3 of Normalized Data- Humans Only") + theme_bw() + guides(color = guide_legend(order=1), size = FALSE, shape = guide_legend(order=2)) + scale_shape_manual(values = c( 0,1,2,3,4,6,7,8)) + scale_color_discrete(name  ="Day", labels=c("0", "1", "2", "3"))

ggplot(data=pcs[chimps,], aes(x=pc1, y=pc3, color=as.factor(day[chimps]+1), shape=as.factor(individual[chimps]), size=2)) + geom_point() + xlab("PC1") + ylab("PC3") + ggtitle("PCs 1 and 3 of Normalized Data- Chimpanzees Only") + theme_bw() + guides(color = guide_legend(order=1), size = FALSE, shape = guide_legend(order=2)) + scale_shape_manual(values = c( 0,1,2,3,4,6,7,8)) + scale_color_discrete(name  ="Day", labels=c("0", "1", "2", "3"))

```

Individual is most highly correlated with PC2 because there are no individuals that are both humans and chimpanzees. It is next most correlated with PC3 (p-value = 0.004732411). 

```{r}
# Relationship between batch and individual

#Performing this test of significance for variables that are categorical data (Using Pearson's chi-squared test)
pval_chi <- chisq.test(as.factor(differentiation_batch), as.factor(individual), simulate.p.value = TRUE)$p.value
pval_chi  

```

### Differentiation batch without 28815 day 2

```{r}
individual_62 <- individual[-21]

differentiation_batch_62 <- differentiation_batch[-21]

pcs_62 <- pcs[-21,]
  
# Differentiation batch

pvaluesandr2_differentiation_batch_62 = matrix(data = NA, nrow = 10, ncol = 2, dimnames = list(c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10"), c("Diff_batch p_val", "Diff_batch R^2")))

j = 1
  for (j in 1:10){
  
  checkPC1 <- lm(pcs_62[,j] ~ as.factor(differentiation_batch_62))

#Get the summary statistics from it
  summary(checkPC1)

#Get the p-value of the F-statistic
  summary(checkPC1)$fstatistic

  fstat <- as.data.frame(summary(checkPC1)$fstatistic)
  p_fstat <- 1-pf(fstat[1,], fstat[2,], fstat[3,])
  
#Fraction of the variance explained by the model
  r2_value <- summary(checkPC1)$r.squared

#Put the summary statistics into the matrix w

  pvaluesandr2_differentiation_batch_62[j, 1] <- p_fstat
  pvaluesandr2_differentiation_batch_62[j, 2] <- r2_value
  
  }

pvaluesandr2_differentiation_batch_62


```


```{r}
# Individual

pvaluesandr2_individual_62 = matrix(data = NA, nrow = 10, ncol = 2, dimnames = list(c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10"), c("Individual p_val", "Individual R^2")))

j = 1
  for (j in 1:10){
  
  checkPC1 <- lm(pcs_62[,j] ~ as.factor(individual_62))

#Get the summary statistics from it
  summary(checkPC1)

#Get the p-value of the F-statistic
  summary(checkPC1)$fstatistic

  fstat <- as.data.frame(summary(checkPC1)$fstatistic)
  p_fstat <- 1-pf(fstat[1,], fstat[2,], fstat[3,])
  
#Fraction of the variance explained by the model
  r2_value <- summary(checkPC1)$r.squared

#Put the summary statistics into the matrix w

  pvaluesandr2_individual_62[j, 1] <- p_fstat
  pvaluesandr2_individual_62[j, 2] <- r2_value
  
}

pvaluesandr2_individual_62
```

```{r}
# Relationship between batch and individual

#Performing this test of significance for variables that are categorical data (Using Pearson's chi-squared test)
pval_chi <- chisq.test(as.factor(differentiation_batch_62), as.factor(individual_62), simulate.p.value = TRUE)$p.value
pval_chi  

```

